import "./chunk-65LFK76I.js";

// node_modules/@riadh-adrani/utils/build/src/string/isEmpty/index.js
function isEmpty(value) {
  return !isString(value) || value.length === 0;
}

// node_modules/@riadh-adrani/utils/build/src/string/isBlank/index.js
function isBlank(value) {
  return !isString(value) || isEmpty(value.trim());
}

// node_modules/@riadh-adrani/utils/build/src/string/capitalize/index.js
function capitalize(str) {
  if (isBlank(str)) {
    throw "(str) is empty or is not a string.";
  }
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}

// node_modules/@riadh-adrani/utils/build/src/string/wrap/index.js
function wrap(value, start, end = start) {
  return `${start}${value}${end}`;
}

// node_modules/@riadh-adrani/utils/build/src/object/areEqual/areEqualShallow.js
function areShallowEqual(obj1, obj2) {
  if (Object.is(obj1, obj2))
    return true;
  if (typeof obj1 !== "object" || typeof obj2 !== "object" || obj1 === null || obj2 === null)
    return false;
}

// node_modules/@riadh-adrani/utils/build/src/object/areEqual/index.js
function areEqual(obj1, obj2, depth = 10) {
  const shallowComparison = areShallowEqual(obj1, obj2);
  if (typeof shallowComparison === "boolean")
    return shallowComparison;
  const key1 = Object.keys(obj1);
  const key2 = Object.keys(obj2);
  if (key1.length !== key2.length)
    return false;
  if ([...key1].sort().join("") !== [...key2].sort().join(""))
    return false;
  for (let i = 0; i < key1.length; i++) {
    const o1 = obj1[key1[i]];
    const o2 = obj2[key1[i]];
    const shallowComparison2 = areShallowEqual(o1, o2);
    if (shallowComparison2 === false)
      return false;
    if (depth > 0) {
      if (!areEqual(o1, o2, depth - 1))
        return false;
    }
  }
  return true;
}

// node_modules/@riadh-adrani/utils/build/src/object/hasProperty/index.js
function hasProperty(object, property) {
  if (["string", "number", "boolean", "bigint", "undefined", "null", "symbol"].includes(typeof object))
    return false;
  if ([null, void 0].includes(object))
    return false;
  return Object.prototype.hasOwnProperty.call(object, property);
}

// node_modules/@riadh-adrani/utils/build/src/object/isFalsy/index.js
function isFalsy(value, additionalFalsyList) {
  const list = Array.isArray(additionalFalsyList) ? additionalFalsyList : [];
  list.push(false, 0, -0, "", null, void 0, NaN);
  return list.includes(value);
}

// node_modules/@riadh-adrani/utils/build/src/object/isFunction/index.js
function isFunction(object) {
  return typeof object === "function";
}

// node_modules/@riadh-adrani/utils/build/src/object/isPrimitiveType/index.js
function isPrimitiveType(object) {
  return ["string", "number", "bigint", "boolean", "undefined", "symbol", "null"].includes(typeof object);
}

// node_modules/@riadh-adrani/utils/build/src/object/getType/index.js
var getType = (o) => {
  if (isNull(o))
    return "null";
  if (isUndefined(o))
    return "undefined";
  if (isNumber(o))
    return "number";
  if (isBigint(o))
    return "bigint";
  if (isString(o))
    return "string";
  if (isBoolean(o))
    return "boolean";
  if (isSymbol(o))
    return "symbol";
  if (isArray(o))
    return "array";
  return "object";
};
var getType_default = getType;

// node_modules/@riadh-adrani/utils/build/src/object/merge/index.js
function merge(...objects) {
  objects.forEach((o) => {
    if (!isObject(o)) {
      throw new Error(`All argument should be of type (object) but one is (${getType_default(o)})`);
    }
  });
  return objects.reduce((output, object) => {
    if (isArray(object)) {
      if (isArray(output)) {
        const l1 = output.length;
        const l2 = object.length;
        for (let i = 0; i < Math.max(l1, l2); i++) {
          if (!hasProperty(output, i)) {
            output[i] = object[i];
          } else if (getType_default(cast(output)[i]) !== "object" || getType_default(cast(object)[i]) !== "object") {
            output[i] = object[i];
          } else {
            cast(output)[i] = merge(output[i], object[i]);
          }
        }
      } else {
        return object;
      }
    } else {
      Object.keys(object).forEach((key) => {
        if (!hasProperty(output, key)) {
          cast(output)[key] = cast(object)[key];
        } else {
          if (getType_default(cast(output)[key]) !== "object" || getType_default(cast(object)[key]) !== "object") {
            cast(output)[key] = cast(object)[key];
          } else {
            cast(output)[key] = merge(output[key], object[key]);
          }
        }
      });
    }
    return output;
  }, {});
}

// node_modules/@riadh-adrani/utils/build/src/object/verify/index.js
function verify_default(...verifiers) {
  for (const fn of verifiers) {
    if (typeof fn === "function") {
      const res = fn();
      if (res === false)
        return false;
    } else {
      if (fn === false)
        return false;
    }
  }
  return true;
}

// node_modules/@riadh-adrani/utils/build/src/object/copy/index.js
function copy(source) {
  if (isFalsy(source) || isPrimitiveType(source) || isFunction(source))
    return source;
  const target = Array.isArray(source) ? [] : {};
  Object.keys(source).forEach((key) => {
    target[key] = copy(source[key]);
  });
  return target;
}

// node_modules/@riadh-adrani/utils/build/src/object/isTrue/index.js
function isTrue(condition) {
  if (typeof condition === "boolean") {
    return condition;
  }
  if (typeof condition !== "function") {
    throw "(condition) should be a boolean or a function";
  }
  const res = condition();
  if (typeof res !== "boolean") {
    throw "(condition) result is not a boolean.";
  }
  return res;
}
function isNumber(o) {
  return isTrue(typeof o === "number");
}
function isString(o) {
  return isTrue(typeof o === "string");
}
function isArray(o) {
  return isTrue(Array.isArray(o));
}
function isObject(o) {
  return isTrue(typeof o === "object");
}
function isNull(o) {
  return isTrue(o === null);
}
function isDefined(o) {
  return isTrue(!isNull(o) && !isUndefined(o));
}
function isUndefined(o) {
  return isTrue(typeof o === "undefined");
}
function isBoolean(o) {
  return isTrue(typeof o === "boolean");
}
function isBigint(o) {
  return typeof o === "bigint";
}
function isSymbol(o) {
  return typeof o === "symbol";
}

// node_modules/@riadh-adrani/utils/build/src/object/forEachKey/index.js
function forEachKey_default(callback, object) {
  if (!isFunction(callback)) {
    throw `Expected a function for (callback) but found (${typeof object}).`;
  }
  if (!isObject(object)) {
    throw `Expected an object for (object) but found (${typeof object}).`;
  }
  Object.keys(object).forEach((key, index) => callback(key, object[key], index));
}

// node_modules/@riadh-adrani/utils/build/src/object/pick/index.js
function pick(object, ...keys) {
  const out = {};
  Object.keys(object).forEach((key) => {
    if (keys.includes(key)) {
      out[key] = object[key];
    }
  });
  return out;
}

// node_modules/@riadh-adrani/utils/build/src/object/omit/index.js
function omit(object, ...keys) {
  const out = Object.assign({}, object);
  Object.keys(out).forEach((key) => {
    if (keys.includes(key)) {
      delete out[key];
    }
  });
  return out;
}

// node_modules/@riadh-adrani/utils/build/src/object/copyKeys/index.js
function copyKeys(source, target, ...exclude) {
  forEachKey_default((key, value) => {
    if (!exclude.includes(key)) {
      target[key] = value;
    }
  }, source);
}

// node_modules/@riadh-adrani/utils/build/src/object/findKey/index.js
function findKey_default(callback, object) {
  for (const k in object) {
    const res = callback(k, object[k]);
    if (res) {
      return { key: k, value: object[k] };
    }
  }
  return void 0;
}

// node_modules/@riadh-adrani/utils/build/src/object/reactive/createReactive.js
var createReactive = (object, onValueChanged) => {
  forEachKey_default((key, value) => {
    if (isObject(value)) {
      object[key] = createReactive(value, onValueChanged);
    }
  }, object);
  let proxied = new Proxy(object, {
    get: (current, key) => {
      return current[key];
    },
    set: (target, key, newValue) => {
      let transformed = newValue;
      if (isObject(newValue)) {
        transformed = createReactive(newValue, onValueChanged);
      }
      cast(target)[key] = transformed;
      onValueChanged();
      return true;
    }
  });
  if (isArray(proxied)) {
    proxied = new ReactiveArray(proxied, onValueChanged);
  }
  return proxied;
};
var createReactive_default = createReactive;

// node_modules/@riadh-adrani/utils/build/src/object/haveCircularDependency/index.js
var keyHasCircularDependency = (o, key, visited = /* @__PURE__ */ new Set()) => {
  if (!["object", "array"].includes(getType_default(o))) {
    return false;
  }
  if (visited.has(o[key])) {
    return true;
  }
  visited.add(o[key]);
  for (const k in o[key]) {
    if (keyHasCircularDependency(o[key], k, visited)) {
      return true;
    }
  }
  visited.delete(o[key]);
  return false;
};
var hasCircularDependency = (o) => {
  if (!["object", "array"].includes(getType_default(o))) {
    return false;
  }
  for (const key in o) {
    if (keyHasCircularDependency(o, key, /* @__PURE__ */ new Set([o]))) {
      return true;
    }
  }
  return false;
};

// node_modules/@riadh-adrani/utils/build/src/string/ellipsify/index.js
function ellipsify_default(text, max, ellipsis = "...") {
  if (!isString(text))
    throw "(text) is not a string.";
  if (!isNumber(max))
    throw "(max) is not a number.";
  if (text.length <= max)
    return text;
  return text.substring(0, max) + ellipsis;
}

// node_modules/@riadh-adrani/utils/build/src/async/runAfter/index.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function runAfter(time, callback) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve) => {
      if (typeof time !== "number" || time < 0) {
        throw "(time) is not valid.";
      }
      if (!isFunction(callback)) {
        throw "(callback) is not a function.";
      }
      setTimeout(() => {
        resolve(callback());
      }, time);
    });
  });
}

// node_modules/@riadh-adrani/utils/build/src/array/reactive/ReactiveArray.js
var ReactiveArray = class extends Array {
  constructor(items, onChanged) {
    if (!isArray(items)) {
      throw `[Utils:ReactiveArray] expected Array but got ${typeof items}`;
    }
    super(...items);
    this.onChanged = () => 0;
    this.onChanged = onChanged;
  }
  get items() {
    return [...this];
  }
  push(...items) {
    const count = super.push(...items);
    if (items.length > 0) {
      this.onChanged();
    }
    return count;
  }
  pop() {
    const before = this.length;
    const item = super.pop();
    const after = this.length;
    if (before !== after) {
      this.onChanged();
    }
    return item;
  }
  shift() {
    const before = this.length;
    const item = super.shift();
    const after = this.length;
    if (before !== after) {
      this.onChanged();
    }
    return item;
  }
  unshift(...items) {
    const before = this.length;
    const count = super.unshift(...items);
    const after = this.length;
    if (before !== after) {
      this.onChanged();
    }
    return count;
  }
  reverse() {
    const items = super.reverse();
    if (this.length > 1) {
      this.onChanged();
    }
    return items;
  }
  // TODO splice not working
  sort(compareFn) {
    const old = [...this.items];
    const sorted = super.sort(compareFn);
    if (!areEqual(old, this.items)) {
      this.onChanged();
    }
    return sorted;
  }
  fill(value, start, end) {
    const old = [...this.items];
    const filled = super.fill(value, start, end);
    if (!areEqual(old, filled.items)) {
      this.onChanged();
    }
    return filled;
  }
  copyWithin(target, start, end) {
    const old = [...this.items];
    const updated = super.copyWithin(target, start, end);
    if (!areEqual(old, this.items)) {
      this.onChanged();
    }
    return updated;
  }
};
var isReactiveArray = (o) => {
  return o instanceof ReactiveArray;
};
var reactiveArray = (array, onChanged) => new ReactiveArray(array, onChanged);

// node_modules/@riadh-adrani/utils/build/src/array/isArrayOf/index.js
function isArrayOf_default(array, condition) {
  if (!Array.isArray(array))
    throw "(array) should be of type array.";
  if (!isFunction(condition) && typeof condition !== "string")
    throw "(verifier) should be a type as string or a callback.";
  return array.every((item) => {
    if (typeof condition === "string") {
      if (typeof item !== condition)
        return false;
    } else {
      if (!condition(item))
        return false;
    }
    return true;
  });
}

// node_modules/@riadh-adrani/utils/build/src/array/range/index.js
function range(start, end) {
  if (typeof end != "number" || typeof start != "number") {
    throw "(end) or (start) is/are not of type number.";
  }
  if (start > end) {
    throw "start number is greater than the end one.";
  }
  const output = [];
  for (let i = start; i < end; i++) {
    output.push(i);
  }
  return output;
}

// node_modules/@riadh-adrani/utils/build/src/array/shuffle/index.js
function shuffle(input) {
  let currentIndex = input.length, randomIndex;
  const array = input;
  while (currentIndex != 0) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;
    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
  }
  return array;
}

// node_modules/@riadh-adrani/utils/build/src/iteration/forRange/index.js
function forRange(callback, start, end, step = 1) {
  if (!isFunction(callback))
    throw "(callback) is not a function.";
  if (!isNumber(end))
    throw "(end) is not a number.";
  if (!isNumber(start))
    throw "(start) is not a number.";
  if (!isNumber(step))
    throw "(step) is not a number.";
  for (let i = start; i < end; i = i + step) {
    const res = callback(i);
    if (res != void 0)
      return res;
  }
}

// node_modules/@riadh-adrani/utils/build/src/array/segmentize/index.js
function segmentize_default(array, segmentLength) {
  const output = [];
  forRange((index) => {
    output.push(array.slice(index, index + segmentLength));
  }, 0, array.length, segmentLength);
  return output;
}

// node_modules/@riadh-adrani/utils/build/src/math/isInInterval/index.js
function isInInterval_default(min, value, max) {
  if (typeof min !== "number")
    throw "(min) is not a number.";
  if (typeof max !== "number")
    throw "(max) is not a number.";
  if (typeof value !== "number")
    throw "(value) is not a number.";
  if (min > max)
    throw "(min) is greater than (max).";
  return min <= value && value <= max;
}

// node_modules/@riadh-adrani/utils/build/src/math/clamp/index.js
function clamp_default(min, n, max) {
  if (typeof min !== "number")
    throw "(min) is not a number";
  if (typeof max !== "number")
    throw "(max) is not a number";
  if (typeof n !== "number")
    throw "(n) is not a number";
  if (min > max)
    throw "(min) is greater than (max)";
  return Math.min(Math.max(n, min), max);
}

// node_modules/@riadh-adrani/utils/build/src/math/random/index.js
function random_default(min, max, float = false) {
  if (!isNumber(min))
    throw "(min) is not a number";
  if (!isNumber(max))
    throw "(max) is not a number";
  if (min > max) {
    throw "(min) is greater than (max).";
  }
  if (min === max) {
    return min;
  }
  const rnd = Math.random() * (max - min) + min;
  return float ? Math.floor(rnd) : rnd;
}

// node_modules/@riadh-adrani/utils/build/src/math/calcDistance/index.js
function calcDistance(x1, y1, x2, y2) {
  if (typeof x1 !== "number")
    throw "(x1) is not a number";
  if (typeof x2 !== "number")
    throw "(x2) is not a number";
  if (typeof y1 !== "number")
    throw "(y1) is not a number";
  if (typeof y2 !== "number")
    throw "(y2) is not a number";
  return Math.sqrt(Math.abs(x1 - x2) ** 2 + Math.abs(y1 - y2) ** 2);
}
function calcDistance3d(x1, y1, z1, x2, y2, z2) {
  if (typeof x1 !== "number")
    throw "(x1) is not a number";
  if (typeof x2 !== "number")
    throw "(x2) is not a number";
  if (typeof y1 !== "number")
    throw "(y1) is not a number";
  if (typeof y2 !== "number")
    throw "(y2) is not a number";
  if (typeof z1 !== "number")
    throw "(z1) is not a number";
  if (typeof z2 !== "number")
    throw "(z2) is not a number";
  return Math.sqrt(Math.abs(x1 - x2) ** 2 + Math.abs(y1 - y2) ** 2 + Math.abs(z1 - z2) ** 2);
}

// node_modules/@riadh-adrani/utils/build/src/time/since/index.js
var SECOND = 1e3;
var MINUTE = SECOND * 60;
var HOUR = MINUTE * 60;
var DAY = HOUR * 24;
var WEEK = DAY * 7;
var MONTH = DAY * 30;
var YEAR = DAY * 365;
function timeUnitSince(time, timeUnit, singular, plural) {
  if (typeof time !== "number") {
    throw new Error("time is not a number.");
  }
  if (time > Date.now()) {
    throw new Error("the given time is superior to the current time.");
  }
  if (typeof timeUnit !== "number" || timeUnit < 0) {
    throw new Error("time unit is not a positive number.");
  }
  const delta = Date.now() - time;
  const count = Math.trunc(delta / timeUnit);
  return {
    count,
    formatted: `${count} ${count < 2 ? singular : plural}`
  };
}
function secondsSince(time, singular = "second", plural = "seconds") {
  return timeUnitSince(time, SECOND, singular, plural);
}
function minutesSince(time, singular = "minute", plural = "minutes") {
  return timeUnitSince(time, MINUTE, singular, plural);
}
function hoursSince(time, singular = "hour", plural = "hours") {
  return timeUnitSince(time, HOUR, singular, plural);
}
function daysSince(time, singular = "day", plural = "days") {
  return timeUnitSince(time, DAY, singular, plural);
}
function weeksSince(time, singular = "week", plural = "weeks") {
  return timeUnitSince(time, WEEK, singular, plural);
}
function monthsSince(time, singular = "month", plural = "months") {
  return timeUnitSince(time, MONTH, singular, plural);
}
function yearsSince(time, singular = "year", plural = "years") {
  return timeUnitSince(time, YEAR, singular, plural);
}
function since(time, _second = ["second", "seconds"], _minute = ["minute", "minutes"], _hour = ["hour", "hours"], _day = ["day", "days"], _week = ["week", "weeks"], _month = ["month", "months"], _year = ["year", "years"]) {
  if (typeof time !== "number") {
    throw new Error("time is not a number.");
  }
  let t = time;
  const years = yearsSince(t, ..._year);
  t += years.count * YEAR;
  const months = monthsSince(t, ..._month);
  t += months.count * MONTH;
  const weeks = weeksSince(t, ..._week);
  t += weeks.count * WEEK;
  const days = daysSince(t, ..._day);
  t += days.count * DAY;
  const hours = hoursSince(t, ..._hour);
  t += hours.count * HOUR;
  const minutes = minutesSince(t, ..._minute);
  t += minutes.count * MINUTE;
  const seconds = secondsSince(t, ..._second);
  const res = {
    formatted: "",
    seconds,
    minutes,
    hours,
    days,
    weeks,
    months,
    years
  };
  res.formatted = (() => {
    if (years.count > 0)
      return years.formatted;
    else if (months.count > 0)
      return months.formatted;
    else if (weeks.count > 0)
      return weeks.formatted;
    else if (days.count > 0)
      return days.formatted;
    else if (hours.count > 0)
      return hours.formatted;
    else if (minutes.count > 0)
      return minutes.formatted;
    else
      return seconds.formatted;
  })();
  return res;
}

// node_modules/@riadh-adrani/utils/build/src/color/hex/index.js
function isHexColor(color) {
  if (isBlank(color))
    return false;
  const three = /^#[0-9|a|A|b|B|c|C|d|D|e|E|f|F]{3}$/;
  const six = /^#[0-9|a|A|b|B|c|C|d|D|e|E|f|F]{6}$/;
  const eight = /^#[0-9|a|A|b|B|c|C|d|D|e|E|f|F]{8}$/;
  return three.test(color) || six.test(color) || eight.test(color);
}

// node_modules/@riadh-adrani/utils/build/src/color/hsl/index.js
function hsla(h, s, l, a = 1) {
  if (!isInInterval_default(0, h, 360))
    throw "(hue) should be a number between 0 and 360";
  if (!isInInterval_default(0, l, 100))
    throw "(lightness) should be a number between 0 and 100";
  if (!isInInterval_default(0, s, 100))
    throw "(saturation) should be a number between 0 and 100";
  if (!isInInterval_default(0, a, 1))
    throw "(alpha) should be a number between 0 and 1";
  return `hsla(${h}deg ${s}% ${l}% / ${a})`;
}
var HSL_REGEX = /^hsl\((\d{1,3})(\.\d+){0,1}deg (\d{1,3})(\.\d+){0,1}% (\d{1,3})(\.\d+){0,1}%\)$/;
var HSLA_REGEX = /^hsla\((\d{1,3})(\.\d+){0,1}deg (\d{1,3})(\.\d+){0,1}% (\d{1,3})(\.\d+){0,1}%( \/ (\d{1,3})(\.\d+){0,1}){0,1}\)$/;
function isHslForm(color) {
  return isBlank(color) ? false : HSL_REGEX.test(color);
}
function isHslaForm(color) {
  return isBlank(color) ? false : HSLA_REGEX.test(color);
}
function extractDataFromHSL(color) {
  if (isHslaForm(color)) {
    return color.slice(5, -1).replace("%", "").replace("deg", "").replace("/", "").replace("  ", " ").split(" ").map((i) => parseFloat(i.trim()));
  }
  if (isHslForm(color)) {
    return color.slice(4, -1).replace("%", "").replace("deg", "").replace("/", "").split(" ").map((i) => parseFloat(i.trim()));
  }
  throw "(color) is not of a HSL/HSLA form.";
}
function isHslColor(color) {
  if (isBlank(color)) {
    return false;
  }
  if (isHslForm(color)) {
    const [h, s, l] = extractDataFromHSL(color);
    if (360 < h || h < 0)
      return false;
    if (100 < s || s < 0)
      return false;
    if (100 < l || l < 0)
      return false;
    return true;
  } else if (isHslaForm(color)) {
    const [h, s, l, a] = extractDataFromHSL(color);
    if (360 < h || h < 0)
      return false;
    if (100 < s || s < 0)
      return false;
    if (100 < l || l < 0)
      return false;
    if (a !== void 0 && (1 < a || a < 0)) {
      return false;
    }
    return true;
  }
  return false;
}

// node_modules/@riadh-adrani/utils/build/src/color/rgb/index.js
function rgba(r, g, b, a = 1) {
  if (!isInInterval_default(0, r, 255))
    throw "(red) should be a number between 0 and 255";
  if (!isInInterval_default(0, b, 255))
    throw "(green) should be a number between 0 and 255";
  if (!isInInterval_default(0, g, 255))
    throw "(blue) should be a number between 0 and 255";
  if (!isInInterval_default(0, a, 1))
    throw "(alpha) should be a number between 0 and 1";
  return `rgba(${r},${g},${b},${a})`;
}
var RGB_REGEX = /^rgb\((\d{1,3})(\.\d+){0,1},( ){0,1}(\d{1,3})(\.\d+){0,1},( ){0,1}(\d{1,3})(\.\d+){0,1}\)$/;
var RGBA_REGEX = /^rgba\((\d{1,3})(\.\d+){0,1},( ){0,1}(\d{1,3})(\.\d+){0,1},( ){0,1}(\d{1,3})(\.\d+){0,1}(,( ){0,1}(\d{1})(\.\d+){0,1}){0,1}\)$/;
function isRgbForm(color) {
  return isBlank(color) ? false : RGB_REGEX.test(color);
}
function isRgbaForm(color) {
  return isBlank(color) ? false : RGBA_REGEX.test(color);
}
function extractDataFromRGB(color) {
  if (isRgbaForm(color)) {
    return color.slice(5, -1).split(",").map((i) => parseFloat(i.trim()));
  }
  if (isRgbForm(color)) {
    return color.slice(4, -1).split(",").map((i) => parseFloat(i.trim()));
  }
  throw "(color) is not of a RGB/RGBA form.";
}
function isRgbColor(color) {
  if (isBlank(color)) {
    return false;
  }
  if (isRgbForm(color)) {
    const [r, g, b] = extractDataFromRGB(color);
    for (const c of [r, g, b]) {
      if (!isInInterval_default(0, c, 256))
        return false;
    }
    return true;
  } else if (isRgbaForm(color)) {
    const [r, g, b, a] = extractDataFromRGB(color);
    for (const c of [r, g, b]) {
      if (!isInInterval_default(0, c, 256))
        return false;
    }
    if (a !== void 0 && !isInInterval_default(0, a, 1))
      return false;
    return true;
  }
  return false;
}

// node_modules/@riadh-adrani/utils/build/src/color/getType/index.js
var HEX = "hex";
var HSL = "hsl";
var RGB = "rgb";
var UNKNOWN = "unknown";
function getColorType(color) {
  return isHexColor(color) ? HEX : isHslColor(color) ? HSL : isRgbColor(color) ? RGB : UNKNOWN;
}

// node_modules/@riadh-adrani/utils/build/src/color/convert/index.js
function hslToRgb(h, s, l) {
  s /= 100;
  l /= 100;
  h = h % 360;
  const c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs(h / 60 % 2 - 1)), m = l - c / 2;
  let r = 0, g = 0, b = 0;
  if (0 <= h && h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (60 <= h && h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (120 <= h && h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (180 <= h && h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (240 <= h && h < 300) {
    r = x;
    g = 0;
    b = c;
  } else if (300 <= h && h < 360) {
    r = c;
    g = 0;
    b = x;
  }
  r = Math.round((r + m) * 255);
  g = Math.round((g + m) * 255);
  b = Math.round((b + m) * 255);
  return [r, g, b];
}
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const cMin = Math.min(r, g, b), cMax = Math.max(r, g, b), delta = cMax - cMin;
  let h = 0, s = 0, l = 0;
  if (delta == 0)
    h = 0;
  else if (cMax == r)
    h = (g - b) / delta % 6;
  else if (cMax == g)
    h = (b - r) / delta + 2;
  else
    h = (r - g) / delta + 4;
  h = Math.round(h * 60);
  if (h < 0)
    h += 360;
  l = (cMax + cMin) / 2;
  s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
  s = +(s * 100).toFixed(2);
  l = +(l * 100).toFixed(2);
  return [round(h), round(s), round(l)];
}
function rgbToHex(r, g, b, a = 1) {
  function formatHex(c) {
    const hex = Math.round(c).toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  }
  return "#" + formatHex(r) + formatHex(g) + formatHex(b) + formatHex(a * 255);
}
var round = (n) => {
  return Math.round(n * 100) / 100;
};
function convertColor(color, to) {
  const type = getColorType(color);
  if (type === UNKNOWN) {
    return color;
  }
  if (![HEX, HSL, RGB].includes(to))
    return color;
  if (to === type)
    return color;
  let [r, g, b, a] = [0, 0, 0, 1];
  if (type === HEX) {
    const c = color.substring(1);
    const l = c.length;
    if (l === 3) {
      r = parseInt(c[0] + c[0], 16);
      g = parseInt(c[1] + c[1], 16);
      b = parseInt(c[2] + c[2], 16);
    } else if (l >= 6) {
      r = parseInt(c.substring(0, 2), 16);
      g = parseInt(c.substring(2, 4), 16);
      b = parseInt(c.substring(4, 6), 16);
      if (l === 8) {
        a = round(parseInt(c.substring(6), 16) / 256);
      }
    }
  } else if (type === HSL) {
    const [h, s, l, _a] = extractDataFromHSL(color);
    if (_a !== void 0) {
      a = _a;
    }
    [r, g, b] = hslToRgb(h, s, l);
  } else if (type === RGB) {
    const [_r, _g, _b, _a] = extractDataFromRGB(color);
    if (_a !== void 0) {
      a = _a;
    }
    [r, g, b] = [_r, _g, _b];
  }
  if (to === RGB) {
    return `rgba(${r},${g},${b},${a})`;
  } else if (to === HSL) {
    const [h, s, l] = rgbToHsl(r, g, b);
    return `hsla(${h}deg ${s}% ${l}% / ${a})`;
  } else if (to === HEX) {
    return rgbToHex(r, g, b, a);
  }
  return color;
}

// node_modules/@riadh-adrani/utils/build/src/color/generate/index.js
function normalizeColorToRgbOrThrow(color) {
  const rgb = convertColor(color, "rgb");
  const t = getColorType(rgb);
  if (t === "unknown") {
    throw "unable to specify (color) type, maybe it is badly formatted ?";
  }
  return rgb;
}
function normalizeColorToHSLOrThrow(color) {
  const rgb = convertColor(color, "hsl");
  const type = getColorType(rgb);
  if (type === "unknown") {
    throw "unable to specify (color) type, maybe it is badly formatted ?";
  }
  return rgb;
}
function generateContrastSafeColor(color, light = "#fff", dark = "#000") {
  const c = normalizeColorToRgbOrThrow(color);
  const [r, g, b] = extractDataFromRGB(c);
  const yiq = (r * 299 + g * 587 + b * 114) / 1e3;
  return yiq >= 128 ? dark : light;
}
function generateComplementaryColor(color, type) {
  const c = normalizeColorToHSLOrThrow(color);
  const [_h, _s, _l, _a] = extractDataFromHSL(c);
  const [h, s, l, a] = [(_h + 180) % 360, _s, _l, _a !== null && _a !== void 0 ? _a : 1];
  const result = `hsla(${h}deg ${s}% ${l}% / ${a})`;
  return convertColor(result, type || "hsl");
}
function generateColorTonalPalette(color, type) {
  const c = normalizeColorToHSLOrThrow(color);
  const palette = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 99, 100];
  const [h, s, , a] = extractDataFromHSL(c);
  const t = type !== null && type !== void 0 ? type : "hsl";
  const colorPalette = {};
  palette.forEach((tone) => {
    const colorTone = hsla(h, s, tone, a !== null && a !== void 0 ? a : 1);
    colorPalette[tone] = convertColor(colorTone, t);
  });
  return colorPalette;
}
function changeColorOpacity(color, opacity, type) {
  const c = normalizeColorToHSLOrThrow(color);
  if (!isInInterval_default(0, opacity, 1))
    throw "(opacity) should be a number between 0 and 1.";
  const [h, s, l] = extractDataFromHSL(c);
  return convertColor(hsla(h, s, l, opacity), type !== null && type !== void 0 ? type : "hex");
}

// node_modules/@riadh-adrani/utils/build/src/type/index.js
var cast = (obj) => {
  return obj;
};
export {
  DAY,
  HEX,
  HOUR,
  HSL,
  HSLA_REGEX,
  HSL_REGEX,
  MINUTE,
  MONTH,
  RGB,
  RGBA_REGEX,
  RGB_REGEX,
  ReactiveArray,
  SECOND,
  UNKNOWN,
  WEEK,
  YEAR,
  areEqual,
  calcDistance,
  calcDistance3d,
  capitalize,
  cast,
  changeColorOpacity,
  clamp_default as clamp,
  convertColor,
  copy,
  copyKeys,
  createReactive_default as createReactive,
  daysSince,
  ellipsify_default as ellipsify,
  extractDataFromHSL,
  extractDataFromRGB,
  findKey_default as findKey,
  forEachKey_default as forEachKey,
  forRange,
  generateColorTonalPalette,
  generateComplementaryColor,
  generateContrastSafeColor,
  getColorType,
  getType_default as getType,
  hasCircularDependency,
  hasProperty,
  hoursSince,
  hslToRgb,
  hsla,
  isArray,
  isArrayOf_default as isArrayOf,
  isBigint,
  isBlank,
  isBoolean,
  isDefined,
  isEmpty,
  isFalsy,
  isFunction,
  isHexColor,
  isHslColor,
  isHslForm,
  isHslaForm,
  isInInterval_default as isInInterval,
  isNull,
  isNumber,
  isObject,
  isPrimitiveType as isPrimitive,
  isReactiveArray,
  isRgbColor,
  isRgbForm,
  isRgbaForm,
  isString,
  isSymbol,
  isTrue,
  isUndefined,
  keyHasCircularDependency,
  merge,
  minutesSince,
  monthsSince,
  omit,
  pick,
  random_default as random,
  range,
  reactiveArray,
  rgbToHex,
  rgbToHsl,
  rgba,
  runAfter,
  secondsSince,
  segmentize_default as segmentize,
  shuffle,
  since,
  timeUnitSince,
  verify_default as verify,
  weeksSince,
  wrap,
  yearsSince
};
//# sourceMappingURL=@riadh-adrani_utils.js.map
